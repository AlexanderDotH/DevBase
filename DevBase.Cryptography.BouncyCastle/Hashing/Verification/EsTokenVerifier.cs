using Org.BouncyCastle.Asn1;
using Org.BouncyCastle.Crypto;
using Org.BouncyCastle.Crypto.Parameters;
using Org.BouncyCastle.Crypto.Signers;
using Org.BouncyCastle.Math;
using Org.BouncyCastle.OpenSsl;

namespace DevBase.Cryptography.BouncyCastle.Hashing.Verification;

/// <summary>
/// Verifies ECDSA signatures for tokens.
/// </summary>
/// <typeparam name="T">The digest algorithm to use (e.g., SHA256).</typeparam>
public class EsTokenVerifier<T> : AsymmetricTokenVerifier where T : IDigest
{
    /// <inheritdoc />
    protected override bool VerifySignature(byte[] content, byte[] signature, string publicKey)
    {
        IDigest digest = (IDigest)Activator.CreateInstance(typeof(T))!;

        using StringReader stringReader = new StringReader(publicKey);
        
        PemReader pemReader = new PemReader(stringReader);
        ECPublicKeyParameters ecPublicKeyParameters = (ECPublicKeyParameters)pemReader.ReadObject();
        
        stringReader.Close();
        
        DsaDigestSigner signer = new DsaDigestSigner(new ECDsaSigner(), digest);
        signer.Init(false, ecPublicKeyParameters);
        signer.BlockUpdate(content, 0, content.Length);

        byte[] asn1Signature = ToAsn1Der(signature);
        return signer.VerifySignature(asn1Signature);
    }

    // Generated by Gemini
    /// <summary>
    /// Converts a P1363 signature format to ASN.1 DER format.
    /// </summary>
    /// <param name="p1363Signature">The P1363 signature bytes.</param>
    /// <returns>The ASN.1 DER encoded signature.</returns>
    private byte[] ToAsn1Der(byte[] p1363Signature)
    {
        int len = p1363Signature.Length / 2;
        
        BigInteger r = new BigInteger(1, p1363Signature.Take(len).ToArray());
        BigInteger s = new BigInteger(1, p1363Signature.Skip(len).ToArray());

        DerSequence seq = new DerSequence(
            new DerInteger(r),
            new DerInteger(s));

        return seq.GetDerEncoded();
    }
}